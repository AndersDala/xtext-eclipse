package org.eclipse.xtext.xtext.ui.wizard.ecore2xtext

import static extension org.eclipse.xtext.xtext.ui.wizard.ecore2xtext.Ecore2XtextExtensions.*
import static extension org.eclipse.xtext.xtext.ui.wizard.ecore2xtext.UniqueNameUtil.*
import org.eclipse.emf.ecore.EClassifier
import org.eclipse.emf.ecore.EDataType
import org.eclipse.emf.ecore.EClass

class Ecore2XtextGrammarCreator {
		
	def grammar(Ecore2XtextProjectInfo it) {
		/*	
			«resetUniqueNames(defaultEPackageInfo)-»
			«FILE basePackagePath+"/"+languageNameAbbreviation+".xtext" -»
			«EXPAND grammarDeclaration-»
			«EXPAND metamodelImport FOREACH allReferencedEPackages()-»
			«EXPAND rules FOR rootElementClass-»
		«EXPAND subClassDispatcherRule FOREACH allDispatcherRuleClasses().remove(rootElementClass)-»
		«EXPAND rule FOREACH allConcreteRuleClassifiers().remove(rootElementClass)-»
		«ENDFILE»
		*/
		defaultEPackageInfo.clearUniqueNames
		'''
		// automatically generated by Xtext
		grammar «languageName» with org.eclipse.xtext.common.Terminals 
		«FOR it: allReferencedEPackages»
		import "«importURI»" «IF uniqueName != null && uniqueName != ""»as «uniqueName»«ENDIF»
		«ENDFOR»
		«rootElementClass.rules»
		'''
	}
	
	/*
	 * «DEFINE rule FOR EClass»
«concreteRuleName()» returns «fqn()»:
«	IF onlyOptionalFeatures()
    	»	{«fqn()»}
«	ENDIF»«
   	FOREACH prefixFeatures() AS prefixFeature
   		»	«EXPAND assignment FOR prefixFeature»«
   	ENDFOREACH
   	»	'«name»'
«	EXPAND idAssignment»«
   	IF !inlinedFeatures().isEmpty
   		»	'{'
«
   		FOREACH allAttributes() AS attribute
   			»		«EXPAND assignment FOR attribute»«
   		ENDFOREACH»«
		FOREACH allCrossReferences() AS crossReference
			»		«EXPAND assignment FOR crossReference»«
   		ENDFOREACH»«
		FOREACH allContainmentReferences() AS containmentReference
			»		«EXPAND assignment FOR containmentReference»«
		ENDFOREACH
		»    '}'«
    ENDIF»;
«ENDDEFINE»
*/
def rule(EClass eClazz)

 /*
«DEFINE subClassDispatcherRule FOR EClass-»
«	IF needsDispatcherRule()»
«uniqueName()» returns «fqn()»:
	«	EXPAND subClassAlternatives»;
«	ENDIF-»
«ENDDEFINE»

«DEFINE subClassAlternatives FOR EClass»«
	FOREACH {this}.union(subClasses()).select(c|c.needsConcreteRule()) AS subClass SEPARATOR " | "»«
		subClass.concreteRuleName()»«
	ENDFOREACH»«
ENDDEFINE»

«DEFINE idAssignment FOR EClass-»
«IF idAttribute() != null»	«idAttribute().name»=«assignedRuleCall(idAttribute())»
«ENDIF-»
«ENDDEFINE»

«DEFINE assignment FOR EStructuralFeature»«
	IF !required 
		»(«
	ENDIF»«
	assignmentKeyword()»«
	IF many»«
		IF isContainment()
			»'{' «
		ELSE 
			»'(' «
		ENDIF»«
	ENDIF»«
	name.quoteIfNeccesary()»«
	EXPAND assignmentOperator»«
	EXPAND assignedTerminal»«
	IF many
		» ( "," «
		name.quoteIfNeccesary()»«
		EXPAND assignmentOperator»«
		EXPAND assignedTerminal
		»)* «
		IF isContainment()
			»'}' «
		ELSE 
			»')' «
		ENDIF»«
	ENDIF»«
	IF !required 
		»)?«
	ENDIF»
«ENDDEFINE»

«DEFINE assignedTerminal FOR EAttribute»«
	assignedRuleCall()»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EReference»«
	IF containment»«
		EReferenceType.uniqueName()»«
	ELSE
		»[«EReferenceType.fqn()»|EString]«
	ENDIF»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EStructuralFeature»«ENDDEFINE»

«DEFINE assignmentOperator FOR EStructuralFeature-»
«IF	many»+=«ELSEIF EType.isBoolean() && isPrefixBooleanFeature()»?=«ELSE»=«ENDIF-»
«ENDDEFINE»

«DEFINE rule FOR EEnum»
enum «name.quoteIfNeccesary()» returns «fqn()»:
	«EXPAND enumAssignment FOREACH ELiterals SEPARATOR " | "»;
«ENDDEFINE»

«DEFINE enumAssignment FOR EEnumLiteral»«name» = '«name»'«ENDDEFINE»
	 
	 */
	def rules(EClassifier eClassifier) {
		if (eClassifier.needsConcreteRule)
			eClassifier.rule
		return ''''''
	}
	
	/**
	 * 
	 * «DEFINE rule FOR EDataType»«
		IF serializable»
		«uniqueName()» returns «fqn()»:
			«dataTypeRuleBody()»;
		«	ENDIF»«
		ENDDEFINE»
		
		«DEFINE rule FOR EClassifier»
		«ERROR "No rule template for " + this.metaType.name»
		«ENDDEFINE»
	 */
	def rule(EDataType it) {
		if (serializable) {
			'''
			«uniqueName» returns «fqn»:
				«dataTypeRuleBody»;
			'''
		}
	}
	
	def rule(EClassifier eClassifier) {
		throw new IllegalStateException("No rule template for "+eClassifier.name)
	}

}