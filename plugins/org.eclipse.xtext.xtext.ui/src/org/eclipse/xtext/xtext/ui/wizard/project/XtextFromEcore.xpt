«IMPORT org::eclipse::emf::ecore»
«IMPORT org::eclipse::xtext::xtext::ui::wizard::project»

«EXTENSION org::eclipse::xtext::xtext::ui::wizard::project::XtextFromEcore»

«DEFINE grammar FOR XtextProjectInfo-»«clearUniqueNames()»
«EXPAND grammarDeclaration-»
«EXPAND metamodelImport FOREACH allImportedEPackages()-»
«EXPAND rule FOR rootElementClass»
«EXPAND rule FOREACH EPackagesForRules.EClassifiers.remove(rootElementClass)-»
«ENDDEFINE»

«DEFINE grammarDeclaration FOR XtextProjectInfo-»
// automatically generated by Xtext
grammar «languageName»  with org.eclipse.xtext.common.Terminals 
«ENDDEFINE»

«DEFINE metamodelImport FOR EPackage»
import "«nsURI»" as «uniqueName()»
«ENDDEFINE» 

«DEFINE rule FOR EClass»
«uniqueName()» returns «fqn()»:
	«EXPAND subClassAlternatives»«
	IF abstract»«
		IF subClasses().isEmpty
			»'«name»' /* TODO: abstract class does not have subclasses. Consider removing this rule */ «
		ENDIF»«
	ELSE»«
		IF !subClasses().isEmpty
			» |
    «	
    	ENDIF»«
    	IF onlyOptionalFeatures()
    		»{«fqn()»} «
    	ENDIF»«
    	EXPAND assignment FOREACH prefixFeatures() SEPARATOR " "»«
    	IF !prefixFeatures().isEmpty
    		» «
    	ENDIF
    	»'«name»' «
    	EXPAND idAssignment»«
    	IF !inlinedFeatures().isEmpty
    		»'{'
        «	
        	EXPAND assignment FOREACH inlinedFeatures() SEPARATOR "\n        "
        	»
    '}'«
    	ENDIF»«
    ENDIF»;
«ENDDEFINE»

«DEFINE subClassAlternatives FOR EClass»«
	FOREACH subClasses() AS subClass SEPARATOR " | "»«
		subClass.uniqueName()»«
	ENDFOREACH»«
ENDDEFINE»

«DEFINE idAssignment FOR EClass-»
«IF idAttribute() != null»«idAttribute().name»=«assignedRuleCall(idAttribute())» «ENDIF-»
«ENDDEFINE»

«DEFINE assignment FOR EStructuralFeature»«
	IF !required 
		»(«
	ENDIF»«
	assignmentKeyword()»«
	IF many»«
		IF isContainment()
			»'{' «
		ELSE 
			»'(' «
		ENDIF»«
	ENDIF»«
	name.quoteIfNeccesary()»«
	EXPAND assignmentOperator»«
	EXPAND assignedTerminal»«
	IF many
		» ( "," «
		name.quoteIfNeccesary()»«
		EXPAND assignmentOperator»«
		EXPAND assignedTerminal
		»)* «
		IF isContainment()
			»'}' «
		ELSE 
			»')' «
		ENDIF»«
	ENDIF»«
	IF !required 
		»)?«
	ENDIF»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EAttribute»«
	assignedRuleCall()»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EReference»«
	IF containment»«
		EReferenceType.uniqueName()»«
	ELSE
		»[«EReferenceType.fqn()»]«
	ENDIF»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EStructuralFeature»«ENDDEFINE»

«DEFINE assignmentOperator FOR EStructuralFeature-»
«IF	many»+=«ELSEIF EType.isBoolean()»?=«ELSE»=«ENDIF-»
«ENDDEFINE»

«DEFINE rule FOR EEnum»
enum «name.quoteIfNeccesary()» returns «fqn()»:
	«EXPAND enumAssignment FOREACH ELiterals SEPARATOR " | "»;
«ENDDEFINE»

«DEFINE enumAssignment FOR EEnumLiteral»«name» = '«name»'«ENDDEFINE»

«DEFINE rule FOR EDataType»«
	IF serializable»
«uniqueName()» returns «fqn()»:
	«dataTypeRuleBody()»;
«	ENDIF»«
ENDDEFINE»

«DEFINE rule FOR EClassifier»
«ERROR "No rule template for " + this.metaType.name»
«ENDDEFINE»


