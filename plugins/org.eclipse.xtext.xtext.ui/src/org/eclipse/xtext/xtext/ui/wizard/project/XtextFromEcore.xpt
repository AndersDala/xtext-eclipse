«IMPORT org::eclipse::emf::ecore»
«IMPORT org::eclipse::xtext::xtext::ui::wizard::project»

«EXTENSION org::eclipse::xtext::xtext::ui::wizard::project::XtextFromEcore»

«DEFINE grammar FOR XtextProjectInfo-»
«EXPAND grammarDeclaration-»
«EXPAND metamodelImport FOREACH importedEPackages.allReferencedEPackages().flatten().toSet()-»
«EXPAND rule FOREACH importedEPackages.EClassifiers.flatten()-»
«ENDDEFINE»

«DEFINE grammarDeclaration FOR XtextProjectInfo-»
// automatically generated by Xtext
grammar «languageName»  with org.eclipse.xtext.common.Terminals 
«ENDDEFINE»

«DEFINE metamodelImport FOR EPackage»
import "«nsURI»" as «alias()»
«ENDDEFINE» 

«DEFINE rule FOR EClass»
«name.quoteIfNeccesary()» returns «fqn()»:
	«EXPAND subClassAlternatives»«
	IF !abstract»«
		IF !subClasses().isEmpty
			» |
    «	
    	ENDIF»«
    	IF onlyOptionalFeatures()
    		»{«fqn()»} «
    	ENDIF»«
    	EXPAND assignment FOREACH prefixFeatures() SEPARATOR " "»«
    	IF !prefixFeatures().isEmpty
    		» «
    	ENDIF
    	»'«name»' «
    	EXPAND idAssignment»«
    	IF !inlinedFeatures().isEmpty
    		»'{'
        «	
        	EXPAND assignment FOREACH inlinedFeatures() SEPARATOR "\n        "
        	»
    '}'«
    	ENDIF»«
    ENDIF»;
«ENDDEFINE»

«DEFINE subClassAlternatives FOR EClass»«
	FOREACH subClasses() AS subClass SEPARATOR " | "»«
		subClass.name.quoteIfNeccesary()»«
	ENDFOREACH»«
ENDDEFINE»

«DEFINE idAssignment FOR EClass-»
«IF idAttribute() != null»«idAttribute().name»=«assignedRuleCall(idAttribute())» «ENDIF-»
«ENDDEFINE»

«DEFINE assignment FOR EStructuralFeature»«
	IF !required 
		»(«
	ENDIF»«
	assignmentKeyword()»«
	IF many»«
		IF isContainment()
			»'{' «
		ELSE 
			»'(' «
		ENDIF»«
	ENDIF»«
	name.quoteIfNeccesary()»«
	EXPAND assignmentOperator»«
	EXPAND assignedTerminal»«
	IF many
		» ( "," «
		name»«
		EXPAND assignmentOperator»«
		EXPAND assignedTerminal
		»)* «
		IF isContainment()
			»'}' «
		ELSE 
			»')' «
		ENDIF»«
	ENDIF»«
	IF !required 
		»)?«
	ENDIF»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EAttribute»«
	assignedRuleCall()»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EReference»«
	IF containment»«
		EReferenceType.name»«
	ELSE
		»[«EReferenceType.fqn()»]«
	ENDIF»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EStructuralFeature»«ENDDEFINE»

«DEFINE assignmentOperator FOR EStructuralFeature-»
«IF	many»+=«ELSEIF EType.isBoolean()»?=«ELSE»=«ENDIF-»
«ENDDEFINE»

«DEFINE rule FOR EEnum»
enum «name.quoteIfNeccesary()» returns «fqn()»:
	«EXPAND enumAssignment FOREACH ELiterals SEPARATOR " | "»;
«ENDDEFINE»

«DEFINE enumAssignment FOR EEnumLiteral»«name» = '«name»'«ENDDEFINE»

«DEFINE rule FOR EDataType»«
	IF !isEcoreType()»
«name.quoteIfNeccesary()» returns «fqn()»:
	'«name»' /* TODO: implement */;
«	ENDIF»«
ENDDEFINE»

«DEFINE rule FOR EClassifier»
«ERROR "No rule template for " + this.metaType.name»
«ENDDEFINE»


