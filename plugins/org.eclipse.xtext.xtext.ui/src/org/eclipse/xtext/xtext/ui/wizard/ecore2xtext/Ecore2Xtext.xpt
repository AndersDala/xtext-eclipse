«REM»
/*******************************************************************************
 * Copyright (c) 2010 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
«ENDREM»

«IMPORT org::eclipse::emf::ecore»
«IMPORT org::eclipse::xtext::xtext::ui::wizard::project»
«IMPORT org::eclipse::xtext::xtext::ui::wizard::ecore2xtext»

«EXTENSION org::eclipse::xtext::xtext::ui::wizard::ecore2xtext::Ecore2Xtext»

«DEFINE grammar FOR Ecore2XtextProjectInfo-»«resetUniqueNames(defaultEPackageInfo)-»
«FILE basePackagePath+"/"+languageNameAbbreviation+".xtext" -»
«EXPAND grammarDeclaration-»
«EXPAND metamodelImport FOREACH EPackageInfos-»
«EXPAND metamodelImport FOREACH missingReferencedEPackages(EPackageInfos.EPackage)-»
«EXPAND rule FOR rootElementClass»
«EXPAND rule FOREACH allRuleClassifiers().remove(rootElementClass)-»
«ENDFILE»
«ENDDEFINE»

«DEFINE grammarDeclaration FOR XtextProjectInfo-»
// automatically generated by Xtext
grammar «languageName» with org.eclipse.xtext.common.Terminals 
«ENDDEFINE»

«DEFINE metamodelImport FOR EPackageInfo»
import "«EPackageImportURI.toString()»" «IF EPackage.uniqueName() != null && EPackage.uniqueName() != ""»as «EPackage.uniqueName()»«ENDIF»
«ENDDEFINE» 

«DEFINE metamodelImport FOR EPackage»
import "«importURI()»" «IF uniqueName() != null && uniqueName() != ""»as «uniqueName()»«ENDIF»
«ENDDEFINE» 

«DEFINE rule FOR EClass»
«uniqueName()» returns «fqn()»:
	«EXPAND subClassAlternatives»«
	IF abstract»«
		IF subClasses().isEmpty
			»'«name»' /* TODO: abstract class does not have subclasses. Consider removing this rule */ «
		ENDIF»«
	ELSE»«
		IF !subClasses().isEmpty
			» |
    «	
    	ENDIF»«
    	IF onlyOptionalFeatures()
    		»{«fqn()»} «
    	ENDIF»«
    	EXPAND assignment FOREACH prefixFeatures() SEPARATOR " "»«
    	IF !prefixFeatures().isEmpty
    		» «
    	ENDIF
    	»'«name»' «
    	EXPAND idAssignment»«
    	IF !inlinedFeatures().isEmpty
    		»'{'
        «	
        	EXPAND assignment FOREACH inlinedFeatures() SEPARATOR "\n        "
        	»
    '}'«
    	ENDIF»«
    ENDIF»;
«ENDDEFINE»

«DEFINE subClassAlternatives FOR EClass»«
	FOREACH subClasses() AS subClass SEPARATOR " | "»«
		subClass.uniqueName()»«
	ENDFOREACH»«
ENDDEFINE»

«DEFINE idAssignment FOR EClass-»
«IF idAttribute() != null»«idAttribute().name»=«assignedRuleCall(idAttribute())» «ENDIF-»
«ENDDEFINE»

«DEFINE assignment FOR EStructuralFeature»«
	IF !required 
		»(«
	ENDIF»«
	assignmentKeyword()»«
	IF many»«
		IF isContainment()
			»'{' «
		ELSE 
			»'(' «
		ENDIF»«
	ENDIF»«
	name.quoteIfNeccesary()»«
	EXPAND assignmentOperator»«
	EXPAND assignedTerminal»«
	IF many
		» ( "," «
		name.quoteIfNeccesary()»«
		EXPAND assignmentOperator»«
		EXPAND assignedTerminal
		»)* «
		IF isContainment()
			»'}' «
		ELSE 
			»')' «
		ENDIF»«
	ENDIF»«
	IF !required 
		»)?«
	ENDIF»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EAttribute»«
	assignedRuleCall()»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EReference»«
	IF containment»«
		EReferenceType.uniqueName()»«
	ELSE
		»[«EReferenceType.fqn()»|EString]«
	ENDIF»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EStructuralFeature»«ENDDEFINE»

«DEFINE assignmentOperator FOR EStructuralFeature-»
«IF	many»+=«ELSEIF EType.isBoolean() && isPrefixBooleanFeature()»?=«ELSE»=«ENDIF-»
«ENDDEFINE»

«DEFINE rule FOR EEnum»
enum «name.quoteIfNeccesary()» returns «fqn()»:
	«EXPAND enumAssignment FOREACH ELiterals SEPARATOR " | "»;
«ENDDEFINE»

«DEFINE enumAssignment FOR EEnumLiteral»«name» = '«name»'«ENDDEFINE»

«DEFINE rule FOR EDataType»«
	IF serializable»
«uniqueName()» returns «fqn()»:
	«dataTypeRuleBody()»;
«	ENDIF»«
ENDDEFINE»

«DEFINE rule FOR EClassifier»
«ERROR "No rule template for " + this.metaType.name»
«ENDDEFINE»

