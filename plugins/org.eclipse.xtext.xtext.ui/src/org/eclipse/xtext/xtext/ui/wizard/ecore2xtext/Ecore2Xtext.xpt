«REM»
/*******************************************************************************
 * Copyright (c) 2010 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
«ENDREM»

«IMPORT org::eclipse::emf::ecore»
«IMPORT org::eclipse::xtext::xtext::ui::wizard::project»
«IMPORT org::eclipse::xtext::xtext::ui::wizard::ecore2xtext»

«EXTENSION org::eclipse::xtext::xtext::ui::wizard::ecore2xtext::Ecore2Xtext»

«DEFINE grammar FOR Ecore2XtextProjectInfo-»
«resetUniqueNames(defaultEPackageInfo)-»
«FILE basePackagePath+"/"+languageNameAbbreviation+".xtext" -»
«EXPAND grammarDeclaration-»
«EXPAND metamodelImport FOREACH allReferencedEPackages()-»
«EXPAND rules FOR rootElementClass-»
«EXPAND subClassDispatcherRule FOREACH allDispatcherRuleClasses().remove(rootElementClass)-»
«EXPAND rule FOREACH allConcreteRuleClassifiers().remove(rootElementClass)-»
«ENDFILE»
«ENDDEFINE»

«DEFINE grammarDeclaration FOR XtextProjectInfo-»
// automatically generated by Xtext
grammar «languageName» with org.eclipse.xtext.common.Terminals 
«ENDDEFINE»

«DEFINE metamodelImport FOR EPackageInfo»
import "«EPackageImportURI.toString()»" «IF EPackage.uniqueName() != null && EPackage.uniqueName() != ""»as «EPackage.uniqueName()»«ENDIF»
«ENDDEFINE» 

«DEFINE metamodelImport FOR EPackage»
import "«importURI()»" «IF uniqueName() != null && uniqueName() != ""»as «uniqueName()»«ENDIF»
«ENDDEFINE» 

«DEFINE rules FOR EClassifier»«
	IF needsConcreteRule()»«
		EXPAND rule»
	«ENDIF-»
«ENDDEFINE»

«DEFINE rule FOR EClass»
«concreteRuleName()» returns «fqn()»:
«	IF onlyOptionalFeatures()
    	»	{«fqn()»}
«	ENDIF»«
   	FOREACH prefixFeatures() AS prefixFeature
   		»	«EXPAND assignment FOR prefixFeature»«
   	ENDFOREACH
   	»	'«name»'
«	EXPAND idAssignment»«
   	IF !inlinedFeatures().isEmpty
   		»	'{'
«
   		FOREACH allAttributes() AS attribute
   			»		«EXPAND assignment FOR attribute»«
   		ENDFOREACH»«
		FOREACH allCrossReferences() AS crossReference
			»		«EXPAND assignment FOR crossReference»«
   		ENDFOREACH»«
		FOREACH allContainmentReferences() AS containmentReference
			»		«EXPAND assignment FOR containmentReference»«
		ENDFOREACH
		»    '}'«
    ENDIF»;
«ENDDEFINE»

«DEFINE subClassDispatcherRule FOR EClass-»
«	IF needsDispatcherRule()»
«uniqueName()» returns «fqn()»:
	«	EXPAND subClassAlternatives»;
«	ENDIF-»
«ENDDEFINE»

«DEFINE subClassAlternatives FOR EClass»«
	FOREACH {this}.union(subClasses()).select(c|c.needsConcreteRule()) AS subClass SEPARATOR " | "»«
		subClass.concreteRuleName()»«
	ENDFOREACH»«
ENDDEFINE»

«DEFINE idAssignment FOR EClass-»
«IF idAttribute() != null»	«idAttribute().name»=«assignedRuleCall(idAttribute())»
«ENDIF-»
«ENDDEFINE»

«DEFINE assignment FOR EStructuralFeature»«
	IF !required 
		»(«
	ENDIF»«
	assignmentKeyword()»«
	IF many»«
		IF isContainment()
			»'{' «
		ELSE 
			»'(' «
		ENDIF»«
	ENDIF»«
	name.quoteIfNeccesary()»«
	EXPAND assignmentOperator»«
	EXPAND assignedTerminal»«
	IF many
		» ( "," «
		name.quoteIfNeccesary()»«
		EXPAND assignmentOperator»«
		EXPAND assignedTerminal
		»)* «
		IF isContainment()
			»'}' «
		ELSE 
			»')' «
		ENDIF»«
	ENDIF»«
	IF !required 
		»)?«
	ENDIF»
«ENDDEFINE»

«DEFINE assignedTerminal FOR EAttribute»«
	assignedRuleCall()»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EReference»«
	IF containment»«
		EReferenceType.uniqueName()»«
	ELSE
		»[«EReferenceType.fqn()»|EString]«
	ENDIF»«
ENDDEFINE»

«DEFINE assignedTerminal FOR EStructuralFeature»«ENDDEFINE»

«DEFINE assignmentOperator FOR EStructuralFeature-»
«IF	many»+=«ELSEIF EType.isBoolean() && isPrefixBooleanFeature()»?=«ELSE»=«ENDIF-»
«ENDDEFINE»

«DEFINE rule FOR EEnum»
enum «name.quoteIfNeccesary()» returns «fqn()»:
	«EXPAND enumAssignment FOREACH ELiterals SEPARATOR " | "»;
«ENDDEFINE»

«DEFINE enumAssignment FOR EEnumLiteral»«name» = '«name»'«ENDDEFINE»

«DEFINE rule FOR EDataType»«
	IF serializable»
«uniqueName()» returns «fqn()»:
	«dataTypeRuleBody()»;
«	ENDIF»«
ENDDEFINE»

«DEFINE rule FOR EClassifier»
«ERROR "No rule template for " + this.metaType.name»
«ENDDEFINE»

