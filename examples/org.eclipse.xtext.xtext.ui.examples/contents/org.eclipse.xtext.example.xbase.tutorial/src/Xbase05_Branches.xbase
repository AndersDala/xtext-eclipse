/*
 * In Xbase everything is an expression, which means that everything yields a result and has some type.
 * What is a statement in Java is an expression in Xbase and can therefore exist where expressions are expected.
 */
 
// If expression
if ('foo'.length>3) {
	'never true!'
} else {
	'always true!'
}
// always true! (String)

// the alse branch is optional and if not specified 'else null' is inferred:
if ('foo'.length>3) {
	'never true!'
}
// null (String)

if (if ('foo'.length>3) false else true) {
	'nested if expressions are not posible in Java'
}
// nested if expressions are not posible in Java (String)

/*
 * The <b>switch expression</b> is different and much more powerful than what you know from Java
 * 
 * First it allows to switch over everything (not only primitives) and it does not have a fall through logic -> first match wins!
 */
val list = newArrayList('foo','bar','baz')
switch(list.head) {
	case 'foo' : "it's foo"
	case 'bar' : 'a bar'
	default : "don't know"
}
// it's foo (String)

/*
 * The type guards are a pragmatic variant of what people often do with pattern matching in functional languages.
 */
import helper.*
val list2 = newArrayList(new SuperType(), new SubType('foo'), new SubType2('bar'))
val result = newArrayList()
for (ele : list2) {
	result +=
		switch (ele) {
			SubType case ele.myProperty=='foo' : 'a sub type : '+ele.myProperty
			SubType2 : 'a sub type2 : '+ele.mySubType2Property
			SuperType : 'a super type'
		}
}
result
// [a super type, a sub type : foo, a sub type2 : bar] (ArrayList<Object>)







